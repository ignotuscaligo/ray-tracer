#pragma once

#include "Image.h"
#include "Object.h"
#include "Photon.h"
#include "PixelSensor.h"
#include "Tree.h"
#include "Volume.h"
#include "WorkQueue.h"

#include <atomic>
#include <memory>
#include <vector>

/*

Pipeline: Photons <-> Hits -> Final hits -> Write

Photons:
* Emitted / bounced photons to cast against the scene
* Generated by lights and emissive volumes at the beginning of a frame
* Generated at bounce sites depending on material properties and number of bounces allowed

Hits:
* Results of photon casts from the previous queue
* Depending on material properties and remaining bounces, will emit more photons to be calculated
* If visible to the camera (normal facing camera, no objects between hit and camera), added to the final hits queue

Final hits:
* Scanned by "pixel sensors" to be written to final image

If photons are available, process those
Else if hits are available, process those
Else if final hits are available, scan those into the image buffer
Else, sleep

*/

class Worker
{
public:
    Worker(size_t index, size_t fetchSize, size_t startPixel, size_t endPixel);

    void start();
    void suspend();
    void resume();
    void stop();
    void exec();
    void startWrite(std::shared_ptr<Tree<PhotonHit>> tree);
    bool writeComplete() const;

    std::shared_ptr<Object> camera;
    std::vector<std::shared_ptr<Object>> objects;
    std::shared_ptr<WorkQueue<Photon>> photonQueue;
    std::shared_ptr<WorkQueue<PhotonHit>> hitQueue;
    std::shared_ptr<WorkQueue<PhotonHit>> finalHitQueue;
    std::shared_ptr<std::vector<PixelSensor>> pixelSensors;
    std::shared_ptr<Tree<PhotonHit>> finalTree;
    std::shared_ptr<Image> image;

    size_t photonDuration = 0;
    size_t hitDuration = 0;
    size_t writeDuration = 0;

    size_t photonsProcessed = 0;
    size_t hitsProcessed = 0;

private:
    bool processPhotons();
    bool processHits();
    bool processWrite();

    size_t m_index = 0;
    size_t m_fetchSize = 0;
    size_t m_startPixel = 0;
    size_t m_endPixel = 0;

    std::atomic_bool m_running;
    std::atomic_bool m_suspend;
    std::atomic_bool m_writePixels;
    std::atomic_bool m_writeComplete;
};
