#pragma once

#include "Buffer.h"
#include "Camera.h"
#include "Image.h"
#include "Material.h"
#include "Object.h"
#include "Photon.h"
#include "Volume.h"
#include "WorkQueue.h"

#include <atomic>
#include <memory>
#include <vector>

/*

Pipeline: Photons <-> Hits -> Final hits -> Write

Photons:
* Emitted / bounced photons to cast against the scene
* Generated by lights and emissive volumes at the beginning of a frame
* Generated at bounce sites depending on material properties and number of bounces allowed

Hits:
* Results of photon casts from the previous queue
* Depending on material properties and remaining bounces, will emit more photons to be calculated
* If visible to the camera (normal facing camera, no objects between hit and camera), added to the final hits queue

Final hits:
* Scanned by "pixel sensors" to be written to final image

If photons are available, process those
Else if hits are available, process those
Else if final hits are available, scan those into the image buffer
Else, sleep

*/

class Worker
{
public:
    Worker(size_t index, size_t fetchSize);

    void start();
    void suspend();
    void resume();
    void stop();
    void exec();

    std::shared_ptr<Camera> camera;
    std::vector<std::shared_ptr<Object>> objects;
    std::shared_ptr<WorkQueue<Photon>> photonQueue;
    std::shared_ptr<WorkQueue<PhotonHit>> hitQueue;
    std::shared_ptr<WorkQueue<PhotonHit>> finalHitQueue;
    std::shared_ptr<MaterialLibrary> materialLibrary;
    std::shared_ptr<Buffer> buffer;
    std::shared_ptr<Image> image;

    size_t photonDuration = 0;
    size_t hitDuration = 0;
    size_t writeDuration = 0;

    size_t photonsProcessed = 0;
    size_t hitsProcessed = 0;
    size_t finalHitsProcessed = 0;

private:
    bool processPhotons();
    bool processHits();
    bool processFinalHits();
    bool processWrite();

    size_t m_index = 0;
    size_t m_fetchSize = 0;

    std::atomic_bool m_running;
    std::atomic_bool m_suspend;
};
